<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;liwybook.top&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="MQ思想浅析消息队列核心当然是消息与队列，是一个消息转发器，模型： 队列模型：纯粹一个队列，先进先出，但是这样的队列，虽然多个生产者能往里仍数据，但一个消息只能被一个消费者接受到，用了就没了。  主题模型（发布订阅）：可以将一份消息分发给多个消费者，订阅某主题的消费者，可以收到全量消息。与队列模式相比，区别在于一份消息是否可以被重复消费。  上面两种区别主要是单播和广播的区别，当只有一个消费者">
<meta property="og:type" content="article">
<meta property="og:title" content="MQ初探">
<meta property="og:url" content="http://liwybook.top/2022/05/04/MQ%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="liwyBook">
<meta property="og:description" content="MQ思想浅析消息队列核心当然是消息与队列，是一个消息转发器，模型： 队列模型：纯粹一个队列，先进先出，但是这样的队列，虽然多个生产者能往里仍数据，但一个消息只能被一个消费者接受到，用了就没了。  主题模型（发布订阅）：可以将一份消息分发给多个消费者，订阅某主题的消费者，可以收到全量消息。与队列模式相比，区别在于一份消息是否可以被重复消费。  上面两种区别主要是单播和广播的区别，当只有一个消费者">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/5qidHsawDS8lANn.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/UfaXEHws9Bz2qyJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/10/pNfxLnQR9hle2dG.png">
<meta property="og:image" content="https://s2.loli.net/2022/05/08/FkHcNBz1U6gJSjl.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/05/09/bJo8ciSV7aQCUF4.png">
<meta property="article:published_time" content="2022-05-04T14:15:40.000Z">
<meta property="article:modified_time" content="2022-06-05T03:02:40.000Z">
<meta property="article:author" content="liwy">
<meta property="article:tag" content="MQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/05/10/5qidHsawDS8lANn.png">


<link rel="canonical" href="http://liwybook.top/2022/05/04/MQ%E5%88%9D%E6%8E%A2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;liwybook.top&#x2F;2022&#x2F;05&#x2F;04&#x2F;MQ%E5%88%9D%E6%8E%A2&#x2F;&quot;,&quot;path&quot;:&quot;2022&#x2F;05&#x2F;04&#x2F;MQ初探&#x2F;&quot;,&quot;title&quot;:&quot;MQ初探&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>MQ初探 | liwyBook</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liwyBook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ%E6%80%9D%E6%83%B3%E6%B5%85%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">MQ思想浅析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E7%AE%80%E6%98%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.1.</span> <span class="nav-text">MQ简易设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.</span> <span class="nav-text">基础功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%89%87"><span class="nav-number">1.3.</span> <span class="nav-text">分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number">1.4.</span> <span class="nav-text">注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">消息队列特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8D%B3%E4%BD%BF%E9%80%9A%E8%AE%AF%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.5.1.</span> <span class="nav-text">1 即使通讯和消息队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">产生的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%88%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E5%93%AA%E4%B8%AA%E7%8E%AF%E8%8A%82%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%89"><span class="nav-number">2.0.1.</span> <span class="nav-text">消息丢失问题（如何知道消息丢失，如何确保消息不丢失，如何确认哪个环节消息丢失）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E6%A3%80%E6%B5%8B"><span class="nav-number">2.0.2.</span> <span class="nav-text">如何进行消息检测?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">2.0.3.</span> <span class="nav-text">有序消息的缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RocketMQ"><span class="nav-number">3.</span> <span class="nav-text">RocketMQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">存储机制</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liwy</p>
  <div class="site-description" itemprop="description">但愿人长久，千里共婵娟。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dustl" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dustl" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:383494201@qq.com" title="E-Mail → mailto:383494201@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liwybook.top/2022/05/04/MQ%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liwy">
      <meta itemprop="description" content="但愿人长久，千里共婵娟。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liwyBook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MQ初探
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-04 22:15:40" itemprop="dateCreated datePublished" datetime="2022-05-04T22:15:40+08:00">2022-05-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-05 11:02:40" itemprop="dateModified" datetime="2022-06-05T11:02:40+08:00">2022-06-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h3 id="MQ思想浅析"><a href="#MQ思想浅析" class="headerlink" title="MQ思想浅析"></a>MQ思想浅析</h3><p>消息队列核心当然是<strong>消息</strong>与<strong>队列</strong>，是一个消息转发器，模型：</p>
<p><strong>队列模型：</strong>纯粹一个队列，先进先出，但是这样的队列，虽然多个生产者能往里仍数据，但一个消息只能被一个消费者接受到，用了就没了。</p>
<p><img src="https://s2.loli.net/2022/05/10/5qidHsawDS8lANn.png" alt="2021-09-06-09-52-09-621185.png"></p>
<p><strong>主题模型（发布订阅）</strong>：可以将一份消息分发给多个消费者，订阅某主题的消费者，可以收到全量消息。与队列模式相比，区别在于一份消息是否可以被重复消费。</p>
<p><img src="https://s2.loli.net/2022/05/10/UfaXEHws9Bz2qyJ.png" alt="2021-09-06-09-52-09-899223.png"></p>
<p>上面两种区别主要是单播和广播的区别，当只有一个消费者订阅某主题时，就是队列模型了</p>
<p><strong>场景：</strong></p>
<p>解耦（系统解耦）、异步（提升系统吞吐量）、流量削峰、延迟通知、最终一致性、顺序消息、流式处理….</p>
<p>对于超出系统承载能力的场景，可以用队列进行限流保护。即：流量削峰</p>
<h4 id="MQ简易设计"><a href="#MQ简易设计" class="headerlink" title="MQ简易设计"></a>MQ简易设计</h4><p>如果只是设计一个粗糙的MQ，那么两次RPC+消息存储即可（Dubbo+JDK自带的阻塞队列，例如ArrayBlockingQueue）</p>
<p>但是如果考虑到生产的方方面面问题，就没那么简单了，例如：</p>
<p>1：高并发场景下，如何保证收发消息的性能？</p>
<p>2：如何保证消息服务的高可用和高可靠？</p>
<p>3 : 如何保证服务是可以水平任意扩展的？</p>
<p>4: 如何保证消息存储也是水平可扩展的？</p>
<p>5: 各种元数据（比如集群中的各个节点、主题、消费关系等）如何管理，需不需要考虑数据的一致性？</p>
<p>将「一发一存一消费」这个核心流程进一步细化后，比较完整的数据流如下：</p>
<p><img src="https://s2.loli.net/2022/05/10/pNfxLnQR9hle2dG.png" alt="2021-09-06-09-52-11-796430.png"></p>
<p>上图三大角色主要负责如下：</p>
<p>Broker：MQ的核心部分，负责消息的存储、备份、删除。为生产者和消费者提供RPC接口。（为什么需要Broker? Broker收到消息后不是直接转给消费方，为了保证消息不丢失，先落盘，存储起来，不影响业务）</p>
<p>Producer: 生产者，消息的生产，调用 Broker 提供的 RPC 接口发送消息。</p>
<p>Consumer:消费者，消息的消费，调用Broker提供的RPC接口接受消息，完成消息的消费。</p>
<h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><p>消息队列需要支持消息的发送、消息暂存，消息异步消费。</p>
<p>除了基本功能以外，消息队列在某些特殊的场景还需要支持事务，消息重试等功能。</p>
<ul>
<li>消息的顺序</li>
<li>消息的可靠性保证</li>
<li>消息的持久化</li>
<li>支持不同消息模型</li>
<li>多实例集群</li>
<li>分布式环境下的负载均衡</li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>一个Broker是部署在某一台服务器上面，这个服务的磁盘存储空间是有限制的，不可能无限扩容。所以当消息量很大的时候，如果只是一直往机器的本地磁盘写数据，最终会写不进去的。</p>
<p>在设计的时候还要考虑数据分片的场景，一个Topic的数据可以分成很多份进行存储，分别存储在不同的Broker上，这样当磁盘不够的时候，可以通过增加Broker的节点来扩容。</p>
<p>那么问题来了，客户端写入的时候怎么知道这个Topic有哪些分片的存储信息，怎么知道有哪些Broker是在线的呢？这就要引入另一个设计：注册中心，在RocketMq中叫NameServer。</p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>注册中心、或者路由中心，为了只是调控Broker、consume、producer,三者。Broker启动的时候需要将自身的信息告诉NameServer，同时也要保持一个心跳检查，这样NameServer才能知道Broker当前是否处于正常状态。NameServer也要支持水平扩展，这样才能保证高可用性。既然要支持水平扩展，那么必然得无状态才行，但是NameServer本身就会存储一些数据，比如Broker信息。</p>
<p>实现方式：</p>
<p>1 ： Broker启动的时候轮流向所有的NameServer进行注册，这样每个NameServer中都有全量的信息，即使某个节点挂了也不影响。RocketMQ就是使用的这种方式。</p>
<p>2： Broker启动的时候只向某一台NameServer进行注册，立马返回，然后NameServer之间再进行相互同步，Eureka就是使用的这种方式。</p>
<p>3： Broker启动的时候只向某一台NameServer进行注册，NameServer会同步向其他的NameServer进行数据的同步操作，等待所有写入成功或者半数写入成功，然后再返回给客户端。Zookeeper就是使用的这种方式。</p>
<p><strong>技术难点与解决方案:</strong></p>
<p><strong>1 通讯</strong></p>
<p>解决三者两两之间的通讯问题，用现有的RPC框架，也可以用Netty作地层通讯，zookeeper作为注册中心，自定义一套新的通信协议（类似 Kafka），也可以基于 AMQP 这种标准化的 MQ 协议来做实现（类似 RabbitMQ）对比直接用 RPC 框架，这种方案的定制化能力和优化空间更大。</p>
<p><strong>2 高可用设计</strong></p>
<p>Broker的高可用，只需保证Broker可水平扩展集群部署，进一步通过服务自动注册与发现、负载均衡、超时重试机制、发送和消费消息时的 ack 机制来保证。</p>
<p>主从：</p>
<p>使用过程中万一这个Broker挂掉了怎么办？这里是不是得考虑下高可用性，所以Broker还需要有主从的设计。</p>
<p>主节点的数据会同步给从节点，主节点出问题后，从节点可以顶上来提供服务，同时从节点也可以提供读的操作，为主节点减轻压力。</p>
<p>存储方案的高可用：参考 Kafka 的分区 + 多副本模式，但是需要考虑分布式场景下数据复制和一致性方案（类似 Zab、Raft等协议），并实现自动故障转移；还可以用主流的 DB、分布式文件系统</p>
<p><strong>3存储设计</strong></p>
<p>主流方案：追加写日志文件（数据部分） + 索引文件的方式（很多主流的开源 MQ 都是这种方式），索引设计上可以考虑稠密索引或者稀疏索引，查找消息可以利用跳转表、二分查找等，还可以通过操作系统的页缓存、零拷贝等技术来提升磁盘文件的读写性能。</p>
<p><strong>4消费关系管理</strong></p>
<p> Broker 是集群部署的，所以消费关系通常维护在公共存储上，可以基于 Zookeeper、Apollo 等配置中心来管理以及进行变更通知。</p>
<p><strong>5高性能设计</strong></p>
<p>业务线程池设计、生产者批量发送、Broker异步刷盘、消费端批量拉取</p>
<h4 id="消息队列特性"><a href="#消息队列特性" class="headerlink" title="消息队列特性"></a>消息队列特性</h4><h5 id="1-即使通讯和消息队列"><a href="#1-即使通讯和消息队列" class="headerlink" title="1 即使通讯和消息队列"></a>1 即使通讯和消息队列</h5><p>从消息能否被即时接受分析处理的角度，可以把消息投递分为两种：</p>
<p>一种是即时消息通讯，消息从消息生产端发送后立刻达到消费端，</p>
<p>一种是延迟消息通讯，有中间消息存储，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。延迟消息通讯的容器实现就是消息队列。</p>
<h3 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h3><p>队列产生的一些问题 ： </p>
<h5 id="消息丢失问题（如何知道消息丢失，如何确保消息不丢失，如何确认哪个环节消息丢失）"><a href="#消息丢失问题（如何知道消息丢失，如何确保消息不丢失，如何确认哪个环节消息丢失）" class="headerlink" title="消息丢失问题（如何知道消息丢失，如何确保消息不丢失，如何确认哪个环节消息丢失）"></a>消息丢失问题（如何知道消息丢失，如何确保消息不丢失，如何确认哪个环节消息丢失）</h5><p>消息丢失：  确保消息的生产、存储、消费阶段。</p>
<p>生产消息阶段： 只要能正常收到Broker的消息ack确认响应，就表示发送成功，处理好返回值和异常，整个阶段是不会丢失的</p>
<p>存储阶段：消息中间件保证，比如broker做副本，保证一条消息至少同步两个节点再返回ack</p>
<p>消费阶段：消费端收到消息后，等到业务执行完成后才发送确认消息</p>
<p>即使如此，也不能保证消息不丢失</p>
<h5 id="如何进行消息检测"><a href="#如何进行消息检测" class="headerlink" title="如何进行消息检测?"></a>如何进行消息检测?</h5><p>消息发送时，生产全局唯一id，或者消息版本号，然后在消费端做对应的消息检验</p>
<p>落地： 在生产端消息发送之前，用拦截器拦截消息，生成消息id（版本号或者分布式全局唯一）,注入消息中，然后在消费端收到消息后，再通过拦截器检验消息的版本号的连续性和消费状态，这样实现的好处是消息检测的代码不会侵入到业务代码中，可以通过单独的任务来定位丢失的消息，做进一步的排查。</p>
<p><strong>如何保证消息不重复消费</strong>？</p>
<p>幂等。也就是任意多次操作产生的影响与一次操作的影响相同。可以写入redis来保证，因为redis的key和value是天然幂等的，或者用数据库的id,基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p><strong>如何保证消息顺序消费</strong>?</p>
<p>RocketMQ在主题上是无序的，它只有在队列层面上是有序的。这里又会有两个概念：普通顺序和严格顺序。</p>
<p>普通顺序是指：消费者通过同一个消息队列接收到的消息是有顺序，不同消息队列接受到的消息可能是无顺序的。</p>
<p>严格顺序是指：消费者接受到的所有消息都是有顺序的，即使是在异常情况下。</p>
<p>严格顺序导致的问题：<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。推荐普通顺序</p>
<p><code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息，如果一个订单，有创建、支付、发货，三个不同消息投放到一个topic的三个不同队列上呢，如何保证顺序？ </p>
<p>可以用Hash取模的方法，保证同一个订单在同一个队列中</p>
<p><strong>如何解决分布式事务</strong> ?</p>
<p> <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。</p>
<p><strong>如何解决消息堆积问题</strong>？ </p>
<p><strong>为什么一个主题需要维护多个队列</strong>？</p>
<p>回答： 提高并发能力。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。</p>
<p>但是呢，这样的话，生产者只能相一个队列投递消息又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？</p>
<p>一些概念介绍 ： </p>
<ul>
<li><p>Producer group : 一类生产组，多个生产者的组合，一个生产组生产一类消息</p>
</li>
<li><p>Consumer group : 一类消费组，消费同类消息</p>
</li>
<li><p>topic : 主题，代表一类消息,例如：物流消息，订单消息。主题中可以有多个队列。</p>
</li>
</ul>
<p>一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>
<p>消费位移：每个消费者组在每个队列中的消费位置都是不同的，为每个消费者组维护一个消费位移，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<h5 id="有序消息的缺陷"><a href="#有序消息的缺陷" class="headerlink" title="有序消息的缺陷"></a>有序消息的缺陷</h5><p>1：发送顺序消息无法利用集群的故障转移特性，不能更换messageQueue进行重试。</p>
<p>2：发送路由策略导致的热点问题，导致某个messageQueue数据量很大。</p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>优势：</p>
<ul>
<li>支持集群，负载均衡，水平扩展</li>
<li>亿极消息堆积</li>
<li>采用零拷贝，顺序写，随机读</li>
<li>底层通讯框架：netty</li>
<li>Nameserv替代zk,实现服务寻址，服务协调</li>
<li>消息失败重试，消息可查</li>
<li>集群无单点</li>
</ul>
<p>RocketMQ 技术架构中有四大角色 ：NameServer，Broker，Producer ，Consumer</p>
<p>那么这几个角色是干啥的? </p>
<p><strong>Broker</strong>: </p>
<ul>
<li>主要负责消息存储，投递，查询以，及服务高可用保证。就是消息队列服务器，生产者把消息投递到Broker,消费者从Broker拉取消息消费。定时向NameServer发送心跳包，那么topic和Broker的关系又如何呢，一个topic可以分布在多个Broker上，一个Broker可以配置多个topic，是多对多的关系。如果一个topic消息量太大，可以多配置队列，或者分布在多个Broker上，减轻单个Broker的压力。如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</li>
</ul>
<p>普通集群：</p>
<p>角色无法切换，当master宕机后slave无法自主切换为master。这一组的Broker就不可用</p>
<p>Dledger集群：</p>
<p>RocketMQ4.5引入，这个模式下，会随机选择一个节点作为master,而当master节点挂掉后，会从slave中自动选择一个节点作为master</p>
<p>Dledger做的事： 1：存储消息到CommitLog 。2：从集群中选举master节点(关键功能，用的是raft算法选举)。3:完成master节点的数据同步至slave。</p>
<p>raft算法（分布式一致性算法）选举：</p>
<p>三个角色： leader、candidate、follower。任期概念：每个任期时间（term）都会选举出一个leader，开始选举的时候每个都是follower,如果没有选举出来，进行下一次选举，每个角色随机睡眠一个时间。集群内会发送一个timeout信号，此时角色转成candidate，没有接受到其他投票请求的时候，自己选自己，把term值递增后发送给各个候选人（这里就是有先发起者优先当选的味道），其他后候选人接受到请求后，比对term值，比自己大的就投票给它，如果比自己小的，就拒绝请求，把票投给自己再发送给其他候选人。选出leader后，选举期间的candidate会转变成follower。leader会和其他follower保持心跳，确认自己的leader地位。也就是说，leader角色的节点是不断变化的。如果一个follower一段时间内没收到leader的心跳，会重新发起一个选举。</p>
<p>选举过程如下：</p>
<ul>
<li>集群启动后，例如有三个节点，发起投票后这三个都是follower。一轮投票后，这个三个候选者的term都是1，选举不出。</li>
<li>一轮选举没选出来，那么就会随机睡眠，例如A 100ms B 200ms C 300ms，然后A先醒来，给自己投票并递增term,发送给其他候选人，B醒来后，接受到A的请求，发现它的term值比自己的1大，那么会选A，承认A是leader,自己会退化成follower这个时候，A已经获得多数票，C醒来后也是一样，投票给A，自己的term会更新为2。此时选举期间的候选者已转换成leader,follower</li>
<li>在一个任期内，leader会给follower发送心跳，如果leader挂了或者其他follower没有收到心跳，会发起新一轮的选举。</li>
</ul>
<p>Dledger采用raft协议进行多副本的消息同步</p>
<p><strong>NameServer</strong>：</p>
<ul>
<li><p>角色类似于Zookeeper，但比zk更轻量级，每个NameServer互相独立没有信息交互。</p>
</li>
<li><p>如果一个Broker的topic数量太多，上万级别（数据几十M），可能在传心跳包的时候传输失败，导致NamerServer没有接收到，出现误判Broker已死。</p>
</li>
<li><p>一个注册中心，主要提供： <strong>Broker管理</strong> 和 <strong>路由信息管理</strong> ，Broker会把自己的信息，注册到NameServer上，消费者和生产者，从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信。生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息。</p>
</li>
</ul>
<p><strong>producer</strong>：</p>
<ul>
<li>消息发布者，支持分布式，集群方式部署。</li>
<li>发送有三种方式： 1 同步，消息发送方发送完后需要等待接收方的回应后才进行下一步操作。2 异步，不需要等待接收方回应就发送下一个数据包。3 单向，不管发送成功还是失败，发了后就不管。主要用于日志收集，用在可靠性不高的场景</li>
</ul>
<p><strong>comsumer</strong>：</p>
<ul>
<li>消息消费的角色，支持分布式、集群部署</li>
<li>负责消费消息，一般后台系统异步消费，不同系统设置不同消费组。如果是不同消费组订阅了同一个topic，对topic的一条消息，每个消费组都会获取到这个消息。</li>
<li>支持pull和push，两种消费模式。支持集群消费和广播消费。</li>
</ul>
<p>消费模式：</p>
<p>pull :</p>
<ul>
<li>消费者主动获取消息</li>
</ul>
<p>特点：</p>
<ul>
<li>需要客户端维护offset，内存，磁盘，数据库</li>
<li>主动消费可控性好，但是间隔时间不好控制，间隔时间短会出先空请求，间隔时间长则消息处理不及时。</li>
</ul>
<p>push:</p>
<p>那么NameServer是干啥用的呢？ </p>
<p>如果Broker直接与生产者，消费者关联，当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>
<p><img src="https://s2.loli.net/2022/05/08/FkHcNBz1U6gJSjl.jpg" alt="24d9e936-2057-4e57-add9-868c4314105a.jpeg"></p>
<p>1：我们看到这张图，broker做了集群，并且主从部署，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)如果 <code>master</code> 宕机，<strong>则</strong> <strong>slave提供消费服务，但是不能写入消息</strong> 。</p>
<p>2：为了保证高可用，NameServer也做了集群部署，注意他是去中心化的，没有中心节点。 <strong>单个Broker和所有NameServer保持长连接</strong></p>
<p>每隔30s，Broker会向，所有NameServer发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息</p>
<p>3：生产者发送消息给Broker消息之前，需要先从NameServer获取Broker的路由消息，然后轮询的方法向每个队列生产数据已达到负载均衡，</p>
<p>4：消费者通过NameServer获取Broker路由消息后，向Broker发送pull请求，获取消息数据，<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>RocketMQ存储架构中的三大角色 ： CommitLog，ConsumeQueue、IndexFile</p>
<p><strong>CommitLog</strong>： 消息主体以及元数据的存储主体</p>
<p><strong>ConsumerQueue</strong>: 消息消费队列，主要为了提高消息消费的性能，作为消费消息的索引。可以看出，consumerQueue文件是基于topic的commitlog索引文件。</p>
<p><strong>IndexFile</strong> : 索引文件，可以通过key或时间区间来查询消息的方法</p>
<p>RocketMQ采用的是混合式的存储结构，把一堆消息不分类的放在一起，那么为啥呢 ? </p>
<p>是为了提高写入数据的效率，但这就牺牲了读的效率，一大批消息太乱了，读取要遍历整个大文件，于是便引入了ConsumeQueue，作为每个队列的索引文件来提升读取消息效率，可以直接根据队列的消息序号，计算出索引的全局位置</p>
<p>架构图：</p>
<p><img src="https://s2.loli.net/2022/05/09/bJo8ciSV7aQCUF4.png" alt="87e3e6f4-e167-4bd3-af1f-5da7c54ad6ec.jpeg"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MQ/" rel="tag"># MQ</a>
          </div>

        
          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/27/%E8%B0%88%E4%B8%80%E8%B0%88ThreadPoolExecutor/" rel="prev" title="谈一谈ThreadPoolExecutor">
                  <i class="fa fa-chevron-left"></i> 谈一谈ThreadPoolExecutor
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NDUzNi8zMTAwNw=="></div><script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liwy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
